<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KStation â€” æ™ºèƒ½äº¤æ˜“å·¥ä½œç«™</title>
    <script src="lightweight-charts.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { background-color: #0b0f19; color: #e5e7eb; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        header { height: 48px; background: #111827; border-bottom: 1px solid #1f2937; display: flex; align-items: center; justify-content: space-between; padding: 0 16px; flex-shrink: 0; }
        .logo { display: flex; align-items: center; gap: 8px; font-weight: bold; color: white; }
        .logo-icon { width: 28px; height: 28px; background: #f97316; border-radius: 6px; display: flex; align-items: center; justify-content: center; color: white; font-size: 16px; font-weight: bold; }
        .header-right { display: flex; align-items: center; gap: 16px; }
        .hotkey-hint { font-size: 11px; color: #6b7280; }
        .status { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #22c55e; }
        .dot { width: 8px; height: 8px; background: #22c55e; border-radius: 50%; box-shadow: 0 0 5px #22c55e; }
        .main-container { flex: 1; display: flex; overflow: hidden; }
        aside { width: 240px; background: #111827; border-right: 1px solid #1f2937; display: flex; flex-direction: column; flex-shrink: 0; }
        .tabs { display: flex; border-bottom: 1px solid #1f2937; }
        .tab { flex: 1; padding: 10px; text-align: center; color: #6b7280; font-size: 12px; cursor: pointer; transition: all 0.2s; }
        .tab.active { color: white; border-bottom: 2px solid #f97316; background: #1f2937; }
        .tab:hover { color: #d1d5db; }
        .watchlist { flex: 1; overflow-y: auto; }
        .stock-row { padding: 10px 12px; border-bottom: 1px solid #1f2937; display: flex; justify-content: space-between; cursor: pointer; transition: background 0.2s; }
        .stock-row:hover { background: #1f2937; }
        .stock-row.active { background: #1f2937; border-left: 3px solid #f97316; }
        .stock-info { display: flex; flex-direction: column; }
        .symbol { font-weight: bold; font-size: 13px; color: white; }
        .name { font-size: 11px; color: #9ca3af; }
        .price-box { text-align: right; }
        .price { font-family: monospace; font-size: 13px; font-weight: bold; }
        .change { font-size: 11px; }
        .text-up { color: #ef4444; }
        .text-down { color: #22c55e; }
        main { flex: 1; display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 1px; background: #000; padding: 1px; }
        .panel { background: #111827; position: relative; display: flex; flex-direction: column; overflow: hidden; }
        .panel-header { position: absolute; top: 8px; left: 8px; right: 8px; z-index: 10; display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
        .badge { background: rgba(31, 41, 55, 0.9); border: 1px solid #374151; color: #f97316; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: bold; font-family: monospace; }
        .tf-group { display: flex; gap: 2px; margin-left: auto; }
        .tf-btn { background: rgba(31, 41, 55, 0.85); border: 1px solid #374151; color: #6b7280; padding: 2px 7px; border-radius: 3px; font-size: 10px; cursor: pointer; font-family: monospace; transition: all 0.15s; }
        .tf-btn:hover { color: #d1d5db; border-color: #4b5563; }
        .tf-btn.active { color: #f97316; border-color: #f97316; background: rgba(249, 115, 22, 0.1); }
        .chart-div { width: 100%; height: 100%; }
        .ai-panel { padding: 20px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; }
        .ai-title { color: #6b7280; font-size: 12px; letter-spacing: 1px; text-transform: uppercase; }
        .ai-stock-name { color: #f97316; font-size: 14px; font-weight: bold; margin: 6px 0; }
        .score { font-size: 72px; font-weight: 900; line-height: 1; margin: 10px 0; }
        .score.high { color: #ef4444; text-shadow: 0 0 20px rgba(239, 68, 68, 0.3); }
        .score.mid { color: #eab308; text-shadow: 0 0 20px rgba(234, 179, 8, 0.3); }
        .score.low { color: #22c55e; text-shadow: 0 0 20px rgba(34, 197, 94, 0.3); }
        .bar-container { width: 100%; max-width: 200px; margin-top: 10px; }
        .bar-row { display: flex; justify-content: space-between; font-size: 11px; color: #9ca3af; margin-bottom: 4px; }
        .progress-bg { height: 6px; background: #1f2937; border-radius: 3px; overflow: hidden; margin-bottom: 12px; }
        .progress-fill { height: 100%; border-radius: 3px; transition: width 0.5s; }
        .data-info { margin-top: 16px; font-size: 10px; color: #4b5563; }
        .info-btn { background: none; border: 1px solid #374151; color: #9ca3af; width: 20px; height: 20px; border-radius: 50%; font-size: 11px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; margin-left: 6px; transition: all 0.2s; vertical-align: middle; }
        .info-btn:hover { color: #f97316; border-color: #f97316; }
        .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 100; align-items: center; justify-content: center; }
        .modal-overlay.show { display: flex; }
        .modal { background: #1f2937; border: 1px solid #374151; border-radius: 12px; padding: 24px; max-width: 380px; width: 90%; color: #e5e7eb; position: relative; }
        .modal h3 { color: #f97316; font-size: 15px; margin-bottom: 14px; }
        .modal p { font-size: 12px; color: #9ca3af; line-height: 1.7; margin-bottom: 10px; }
        .modal .formula { background: #111827; border: 1px solid #374151; border-radius: 6px; padding: 10px 12px; font-family: monospace; font-size: 12px; color: #facc15; margin: 10px 0; }
        .modal .legend { display: flex; align-items: center; gap: 6px; font-size: 11px; margin: 4px 0; }
        .modal .legend-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
        .modal-close { position: absolute; top: 12px; right: 14px; background: none; border: none; color: #6b7280; font-size: 18px; cursor: pointer; }
        .modal-close:hover { color: white; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #6b7280; font-size: 12px; z-index: 5; }
        .kbar-count { position: absolute; bottom: 6px; right: 10px; font-size: 10px; color: #4b5563; font-family: monospace; z-index: 10; pointer-events: none; }
        .ohlc-display { font-size: 10px; font-family: monospace; display: inline-flex; gap: 6px; margin-left: 8px; flex-wrap: wrap; align-items: center; }
        .ohlc-display span { white-space: nowrap; }
        .indicator-group { display: flex; gap: 2px; margin-left: 4px; }
        .ind-btn { background: rgba(31, 41, 55, 0.85); border: 1px solid #374151; color: #6b7280; padding: 2px 5px; border-radius: 3px; font-size: 9px; cursor: pointer; font-family: monospace; transition: all 0.15s; }
        .ind-btn:hover { color: #d1d5db; border-color: #4b5563; }
        .ind-btn.active { color: #f97316; border-color: #f97316; background: rgba(249, 115, 22, 0.1); }
        @keyframes flashUp { 0% { background: rgba(239, 68, 68, 0.3); } 100% { background: transparent; } }
        @keyframes flashDown { 0% { background: rgba(34, 197, 94, 0.3); } 100% { background: transparent; } }
        .flash-up { animation: flashUp 0.5s; }
        .flash-down { animation: flashDown 0.5s; }
        @media (max-width: 768px) {
            aside { display: none; }
            main { grid-template-columns: 1fr; grid-template-rows: 1fr 1fr 1fr auto; }
        }
    </style>
</head>
<body>
<header>
    <div class="logo">
        <div class="logo-icon">K</div>
        <span>KStation <span style="font-weight:normal; color:#6b7280; font-size:12px;">v1.6 Futures</span></span>
    </div>
    <div class="header-right">
        <span class="hotkey-hint">â†‘â†“ åˆ‡æ› Â· Click é¸è‚¡</span>
        <div class="status"><div class="dot"></div> LIVE</div>
    </div>
</header>
<div class="main-container">
    <aside>
        <div class="tabs">
            <div class="tab active" onclick="switchTab('futures')">å€‹è‚¡æœŸ</div>
            <div class="tab" onclick="switchTab('tw')">ç¾è²¨</div>
        </div>
        <div class="watchlist" id="watchlist"></div>
    </aside>
    <main>
        <div class="panel">
            <div class="panel-header">
                <span class="badge" id="badge-0">-- 1åˆ†K</span>                <div class="ohlc-display" id="ohlc-0"></div>
                <div class="indicator-group" id="ind-group-0"></div>
                <div class="tf-group" id="tf-group-0"></div>
            </div>
            <div id="chart-0" class="chart-div"></div>
            <div class="loading" id="loading-0">è¼‰å…¥ä¸­...</div>
            <div class="kbar-count" id="kbar-count-0"></div>
        </div>
        <div class="panel">
            <div class="panel-header">
                <span class="badge" id="badge-1">-- 60åˆ†</span>
                <div class="ohlc-display" id="ohlc-1"></div>
                <div class="indicator-group" id="ind-group-1"></div>
                <div class="tf-group" id="tf-group-1"></div>
            </div>
            <div id="chart-1" class="chart-div"></div>
            <div class="loading" id="loading-1">è¼‰å…¥ä¸­...</div>
            <div class="kbar-count" id="kbar-count-1"></div>
        </div>
        <div class="panel">
            <div class="panel-header">
                <span class="badge" id="badge-2">-- 15åˆ†</span>
                <div class="ohlc-display" id="ohlc-2"></div>
                <div class="indicator-group" id="ind-group-2"></div>
                <div class="tf-group" id="tf-group-2"></div>
            </div>
            <div id="chart-2" class="chart-div"></div>
            <div class="loading" id="loading-2">è¼‰å…¥ä¸­...</div>
            <div class="kbar-count" id="kbar-count-2"></div>
        </div>
        <div class="panel ai-panel" id="ai-panel">
            <div class="ai-title">AI è¶¨å‹¢è©•åˆ† <button class="info-btn" onclick="toggleModal(true)" title="ç®—æ³•èªªæ˜">?</button></div>
            <div class="ai-stock-name" id="ai-stock-name">--</div>
            <div class="score high" id="ai-score">--</div>
            <div class="bar-container">
                <div class="bar-row"><span>å‹•èƒ½</span><span id="bar-momentum-label">--</span></div>
                <div class="progress-bg"><div class="progress-fill" id="bar-momentum" style="width:0%;background:#22c55e"></div></div>
                <div class="bar-row"><span>è¶¨å‹¢</span><span id="bar-trend-label">--</span></div>
                <div class="progress-bg"><div class="progress-fill" id="bar-trend" style="width:0%;background:#22c55e"></div></div>
                <div class="bar-row"><span>é‡èƒ½</span><span id="bar-volume-label">--</span></div>
                <div class="progress-bg"><div class="progress-fill" id="bar-volume" style="width:0%;background:#eab308"></div></div>
            </div>
            <div class="data-info" id="data-info"></div>
        </div>
    </main>
</div>
<div class="modal-overlay" id="algo-modal" onclick="if(event.target===this)toggleModal(false)">
    <div class="modal">
        <button class="modal-close" onclick="toggleModal(false)">&times;</button>
        <h3>ğŸ“Š è©•åˆ†ç®—æ³•èªªæ˜</h3>
        <p>ç¶œåˆè©•åˆ†ç”±ä¸‰å€‹æŒ‡æ¨™åŠ æ¬Šè¨ˆç®—ï¼š</p>
        <div class="formula">ç¸½åˆ† = å‹•èƒ½Ã—40% + è¶¨å‹¢Ã—40% + é‡èƒ½Ã—20%</div>
        <p><b>å‹•èƒ½ (Momentum)</b><br>æ”¶ç›¤åƒ¹ç›¸å° MA5 çš„åé›¢ç¨‹åº¦ï¼Œåæ˜ çŸ­æœŸåƒ¹æ ¼å‹•èƒ½æ–¹å‘ã€‚åé›¢è¶Šå¤§ï¼Œåˆ†æ•¸è¶Šæ¥µç«¯ã€‚</p>
        <p><b>è¶¨å‹¢ (Trend)</b><br>æ”¶ç›¤åƒ¹ç›¸å° MA10 çš„åé›¢ç¨‹åº¦ï¼Œè¡¡é‡ä¸­æœŸè¶¨å‹¢å¼·åº¦ã€‚ç«™ä¸Šå‡ç·šç‚ºæ­£å‘ï¼Œè·Œç ´ç‚ºè² å‘ã€‚</p>
        <p><b>é‡èƒ½ (Volume)</b><br>æˆäº¤é‡ç›¸å°è¿‘æœŸå‡é‡çš„æ´»èºåº¦è©•ä¼°ã€‚</p>
        <hr style="border-color:#374151; margin:14px 0">
        <div class="legend"><div class="legend-dot" style="background:#ef4444"></div> â‰¥65 å¼·å‹¢ â€” å¤šæ–¹ä¸»å°</div>
        <div class="legend"><div class="legend-dot" style="background:#eab308"></div> 40-64 ä¸­æ€§ â€” è§€æœ›æ•´ç†</div>
        <div class="legend"><div class="legend-dot" style="background:#22c55e"></div> &lt;40 åå¼± â€” ç©ºæ–¹å£“åŠ›</div>
        <p style="margin-top:12px;font-size:10px;color:#4b5563">âš ï¸ åƒ…ä¾›åƒè€ƒï¼Œä¸æ§‹æˆæŠ•è³‡å»ºè­°ã€‚</p>
    </div>
</div>
<script>
function toggleModal(show) { document.getElementById('algo-modal').classList.toggle('show', show); }
</script>
<script>
// ===== Config =====
const API_BASE = 'https://hts2.tail45e5a8.ts.net/api';
const DATA_DATE = '20260211';

// Static fallback lists
const twStocks = [
    { stockId: '2330', name: 'å°ç©é›»', price: 1920 },
    { stockId: '2317', name: 'é´»æµ·', price: 208 },
    { stockId: '2454', name: 'è¯ç™¼ç§‘', price: 1585 },
];
let futuresList = [];

let currentProduct = null;
let currentTab = 'futures';
let charts = {};
let rawCandles = [], rawVolumes = []; // cached 1m data
// Per-panel candle/volume data (after aggregation)
let panelCandles = [[], [], []], panelVolumes = [[], [], []];
// Per-panel active indicators
let panelIndicators = [{}, {}, {}]; // e.g. { MA5: true, MA10: false, BB20: true, MACD: false }
// Per-panel indicator series references
let panelIndSeries = [{}, {}, {}];
// Daily cache: { symbol: { dateStr: { candles, volumes } } }
let dailyCache = {};

const TIMEFRAMES = [
    { key: '1m', label: '1åˆ†', minutes: 1 },
    { key: '5m', label: '5åˆ†', minutes: 5 },
    { key: '15m', label: '15åˆ†', minutes: 15 },
    { key: '30m', label: '30åˆ†', minutes: 30 },
    { key: '60m', label: '60åˆ†', minutes: 60 },
    { key: 'D', label: 'æ—¥ç·š', minutes: 0 },
];
// Default timeframe per panel index
const panelTF = ['1m', '60m', '15m'];

const INDICATORS = [
    { key: 'MA5', label: 'MA5', color: '#ffffff' },
    { key: 'MA10', label: 'MA10', color: '#3b82f6' },
    { key: 'MA20', label: 'MA20', color: '#facc15' },
    { key: 'BB20', label: 'BB', color: '#a78bfa' },
    { key: 'MACD', label: 'MACD', color: '#f97316' },
];

// ===== API =====
async function fetchProductList() {
    try {
        const resp = await fetch(API_BASE, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ apiType: 'getProductList' })
        });
        const json = await resp.json();
        if (json.status === 'success') {
            return json.data.map(p => ({ ...p, price: 0 }));
        }
        return [];
    } catch(e) { console.error(e); return []; }
}

async function fetchKLineData(symbol, date, type) {
    try {
        const resp = await fetch(API_BASE, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ apiType: 'getKLine', symbol: symbol, date: date, type: type || '1m' })
        });
        const json = await resp.json();
        if (json.status === 'success' && json.data) return json.data;
        return null;
    } catch (e) {
        return null;
    }
}

// ===== Convert API data to chart format =====
function apiToCandles(apiData, dateStr) {
    if (!apiData || !apiData.length) return { candles: [], volumes: [] };
    const y = parseInt(dateStr.substring(0, 4));
    const m = parseInt(dateStr.substring(4, 6)) - 1;
    const d = parseInt(dateStr.substring(6, 8));
    const candles = [], volumes = [];
    apiData.forEach(bar => {
        const hh = Math.floor(bar.time / 100);
        const mm = bar.time % 100;
        const ts = Math.floor(Date.UTC(y, m, d, hh, mm) / 1000) - 8 * 3600;
        const o = bar.open / 100, h = bar.high / 100, l = bar.low / 100, c = bar.close / 100;
        candles.push({ time: ts, open: o, high: h, low: l, close: c });
        volumes.push({ time: ts, value: bar.vol, color: c >= o ? 'rgba(239,68,68,0.5)' : 'rgba(34,197,94,0.5)' });
    });
    return { candles, volumes };
}

// ===== Aggregate bars =====
function aggregateBars(candles, volumes, minutes) {
    if (!candles.length) return { candles: [], volumes: [] };
    const aggC = [], aggV = [];
    const sec = minutes * 60;
    let i = 0;
    while (i < candles.length) {
        const slot = Math.floor(candles[i].time / sec) * sec;
        let o = candles[i].open, h = candles[i].high, l = candles[i].low, c = candles[i].close, vol = 0;
        while (i < candles.length && Math.floor(candles[i].time / sec) * sec === slot) {
            h = Math.max(h, candles[i].high);
            l = Math.min(l, candles[i].low);
            c = candles[i].close;
            vol += (volumes[i] ? volumes[i].value : 0);
            i++;
        }
        aggC.push({ time: slot, open: o, high: h, low: l, close: c });
        aggV.push({ time: slot, value: vol, color: c >= o ? 'rgba(239,68,68,0.5)' : 'rgba(34,197,94,0.5)' });
    }
    return { candles: aggC, volumes: aggV };
}

// ===== Daily multi-day: generate trading days (skip weekends) =====
function getTradingDays(endDateStr, count) {
    const y = parseInt(endDateStr.substring(0, 4));
    const m = parseInt(endDateStr.substring(4, 6)) - 1;
    const d = parseInt(endDateStr.substring(6, 8));
    const dates = [];
    let dt = new Date(y, m, d);
    while (dates.length < count) {
        const dow = dt.getDay();
        if (dow !== 0 && dow !== 6) {
            const yy = dt.getFullYear();
            const mm = String(dt.getMonth() + 1).padStart(2, '0');
            const dd = String(dt.getDate()).padStart(2, '0');
            dates.unshift(`${yy}${mm}${dd}`);
        }
        dt.setDate(dt.getDate() - 1);
    }
    return dates;
}

async function fetchDailyData(symbol, endDateStr, numDays) {
    const tradingDays = getTradingDays(endDateStr, numDays);
    const dailyCandles = [], dailyVolumes = [];
    // Fetch all days in parallel (cached results return instantly)
    const results = await Promise.all(tradingDays.map(async dateStr => {
        const cacheKey = `${symbol}_${dateStr}`;
        if (dailyCache[cacheKey]) return { dateStr, data: dailyCache[cacheKey] };
        const data = await fetchKLineData(symbol, dateStr, '1m');
        const parsed = apiToCandles(data || [], dateStr);
        dailyCache[cacheKey] = parsed;
        return { dateStr, data: parsed };
    }));
    results.forEach(({ dateStr, data }) => {
        if (!data.candles.length) return;
        const c = data.candles, v = data.volumes;
        const o = c[0].open, cl = c[c.length - 1].close;
        let hi = -Infinity, lo = Infinity, vol = 0;
        c.forEach(bar => { hi = Math.max(hi, bar.high); lo = Math.min(lo, bar.low); });
        v.forEach(bar => { vol += bar.value; });
        const dayStr = dateStr.substring(0, 4) + '-' + dateStr.substring(4, 6) + '-' + dateStr.substring(6, 8);
        dailyCandles.push({ time: dayStr, open: o, high: hi, low: lo, close: cl });
        dailyVolumes.push({ time: dayStr, value: vol, color: cl >= o ? 'rgba(239,68,68,0.5)' : 'rgba(34,197,94,0.5)' });
    });
    return { candles: dailyCandles, volumes: dailyVolumes };
}

// ===== Indicator Calculations =====
function calcMA(candles, period) {
    const result = [];
    for (let i = period - 1; i < candles.length; i++) {
        let s = 0;
        for (let j = 0; j < period; j++) s += candles[i - j].close;
        result.push({ time: candles[i].time, value: s / period });
    }
    return result;
}

function calcBB(candles, period, mult) {
    const mid = [], upper = [], lower = [];
    for (let i = period - 1; i < candles.length; i++) {
        let s = 0;
        for (let j = 0; j < period; j++) s += candles[i - j].close;
        const mean = s / period;
        let sq = 0;
        for (let j = 0; j < period; j++) sq += (candles[i - j].close - mean) ** 2;
        const std = Math.sqrt(sq / period);
        mid.push({ time: candles[i].time, value: mean });
        upper.push({ time: candles[i].time, value: mean + mult * std });
        lower.push({ time: candles[i].time, value: mean - mult * std });
    }
    return { mid, upper, lower };
}

function calcMACD(candles, fast, slow, signal) {
    // EMA helper
    function ema(data, period) {
        const k = 2 / (period + 1);
        const result = [data[0]];
        for (let i = 1; i < data.length; i++) result.push(data[i] * k + result[i - 1] * (1 - k));
        return result;
    }
    const closes = candles.map(c => c.close);
    if (closes.length < slow) return { macd: [], signal: [], histogram: [] };
    const emaFast = ema(closes, fast);
    const emaSlow = ema(closes, slow);
    const macdLine = emaFast.map((v, i) => v - emaSlow[i]);
    const sigLine = ema(macdLine, signal);
    const result = { macd: [], signal: [], histogram: [] };
    // Only output after slow period for meaningful values
    const start = slow - 1;
    for (let i = start; i < candles.length; i++) {
        const t = candles[i].time;
        const m = macdLine[i], s = sigLine[i], h = m - s;
        result.macd.push({ time: t, value: m });
        result.signal.push({ time: t, value: s });
        result.histogram.push({ time: t, value: h, color: h >= 0 ? 'rgba(239,68,68,0.7)' : 'rgba(34,197,94,0.7)' });
    }
    return result;
}

// ===== Chart Creation (LightweightCharts v5) =====
function makeChart(containerId, isDaily) {
    const el = document.getElementById(containerId);
    if (!el) return null;
    const opts = {
        layout: { background: { color: '#111827' }, textColor: '#9ca3af' },
        grid: { vertLines: { color: '#1f2937' }, horzLines: { color: '#1f2937' } },
        timeScale: {
            borderColor: '#374151',
            timeVisible: !isDaily,
            secondsVisible: false,
            rightOffset: 5,
        },
        rightPriceScale: { borderColor: '#374151' },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    };
    if (!isDaily) {
        opts.timeScale.tickMarkFormatter = (time) => {
            const d = new Date(time * 1000);
            const mm = String(d.getMonth()+1).padStart(2,'0');
            const dd = String(d.getDate()).padStart(2,'0');
            const HH = String(d.getHours()).padStart(2,'0');
            const MM = String(d.getMinutes()).padStart(2,'0');
            return `${mm}/${dd} ${HH}:${MM}`;
        };
        opts.localization = {
            timeFormatter: (time) => {
                const d = new Date(time * 1000);
                const mm = String(d.getMonth()+1).padStart(2,'0');
                const dd = String(d.getDate()).padStart(2,'0');
                const HH = String(d.getHours()).padStart(2,'0');
                const MM = String(d.getMinutes()).padStart(2,'0');
                const SS = String(d.getSeconds()).padStart(2,'0');
                return `${mm}/${dd} ${HH}:${MM}:${SS}`;
            },
        };
    }
    const chart = LightweightCharts.createChart(el, opts);
    const candleSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
        upColor: '#ef4444', downColor: '#22c55e',
        borderUpColor: '#ef4444', borderDownColor: '#22c55e',
        wickUpColor: '#ef4444', wickDownColor: '#22c55e',
    });
    const volumeSeries = chart.addSeries(LightweightCharts.HistogramSeries, {
        priceFormat: { type: 'volume' },
        priceScaleId: 'vol',
    });
    chart.priceScale('vol').applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });
    new ResizeObserver(entries => {
        if (!entries.length) return;
        const { width, height } = entries[0].contentRect;
        chart.applyOptions({ width, height });
    }).observe(el);
    return { chart, candleSeries, volumeSeries };
}

// ===== OHLC Display =====
function updateOHLC(panelIdx, bar) {
    const el = document.getElementById('ohlc-' + panelIdx);
    if (!el) return;
    if (!bar) { el.innerHTML = ''; return; }
    const isUp = bar.close >= bar.open;
    const color = isUp ? '#ef4444' : '#22c55e';
    el.innerHTML = `<span style="color:${color}">O:${bar.open.toFixed(2)}</span>` +
        `<span style="color:${color}">H:${bar.high.toFixed(2)}</span>` +
        `<span style="color:${color}">L:${bar.low.toFixed(2)}</span>` +
        `<span style="color:${color}">C:${bar.close.toFixed(2)}</span>` +
        (bar.volume !== undefined ? `<span style="color:#9ca3af">V:${bar.volume}</span>` : '');
}

function showLatestOHLC(panelIdx) {
    const candles = panelCandles[panelIdx];
    const volumes = panelVolumes[panelIdx];
    if (!candles || !candles.length) return;
    const last = candles[candles.length - 1];
    const lastV = volumes[candles.length - 1];
    updateOHLC(panelIdx, { ...last, volume: lastV ? lastV.value : 0 });
}

// ===== Crosshair Sync =====
let crosshairSyncing = false;

function setupCrosshairSync(panelIdx) {
    if (!charts[panelIdx]) return;
    charts[panelIdx].chart.subscribeCrosshairMove(param => {
        if (crosshairSyncing) return;
        crosshairSyncing = true;
        try {
            // Update OHLC for this panel
            if (param.time) {
                const candles = panelCandles[panelIdx];
                const volumes = panelVolumes[panelIdx];
                // Find the bar at this time
                const idx = candles.findIndex(c => {
                    if (typeof c.time === 'string' && typeof param.time === 'object') {
                        // business day comparison
                        const p = param.time;
                        const cStr = c.time;
                        const pStr = `${p.year}-${String(p.month).padStart(2,'0')}-${String(p.day).padStart(2,'0')}`;
                        return cStr === pStr;
                    }
                    return c.time === param.time;
                });
                if (idx >= 0) {
                    updateOHLC(panelIdx, { ...candles[idx], volume: volumes[idx] ? volumes[idx].value : 0 });
                }
                // Sync other panels
                for (let i = 0; i < 3; i++) {
                    if (i === panelIdx || !charts[i]) continue;
                    const otherCandles = panelCandles[i];
                    if (!otherCandles || !otherCandles.length) continue;
                    // Find closest time in other panel
                    let targetTime = param.time;
                    if (typeof param.time === 'object' && typeof otherCandles[0].time === 'string') {
                        // business day obj -> string
                        targetTime = `${param.time.year}-${String(param.time.month).padStart(2,'0')}-${String(param.time.day).padStart(2,'0')}`;
                    } else if (typeof param.time !== 'object' && typeof otherCandles[0].time === 'string') {
                        // Unix ts -> find closest by converting
                        // Skip sync between incompatible time formats
                        continue;
                    } else if (typeof param.time === 'object' && typeof otherCandles[0].time === 'number') {
                        // business day -> can't sync to intraday easily
                        continue;
                    }
                    // Find closest
                    let closest = otherCandles[0];
                    let minDiff = Infinity;
                    if (typeof targetTime === 'number') {
                        for (const c of otherCandles) {
                            const diff = Math.abs(c.time - targetTime);
                            if (diff < minDiff) { minDiff = diff; closest = c; }
                        }
                    } else {
                        // String comparison for daily
                        closest = otherCandles.find(c => c.time === targetTime) || otherCandles[otherCandles.length - 1];
                    }
                    try {
                        charts[i].chart.setCrosshairPosition(closest.close, closest.time, charts[i].candleSeries);
                    } catch(e) {}
                    // Update OHLC for synced panel
                    const cIdx = otherCandles.indexOf(closest);
                    if (cIdx >= 0) {
                        updateOHLC(i, { ...closest, volume: panelVolumes[i][cIdx] ? panelVolumes[i][cIdx].value : 0 });
                    }
                }
            } else {
                // Mouse left - clear crosshairs and show latest OHLC
                for (let i = 0; i < 3; i++) {
                    if (i === panelIdx || !charts[i]) continue;
                    try { charts[i].chart.clearCrosshairPosition(); } catch(e) {}
                    showLatestOHLC(i);
                }
                showLatestOHLC(panelIdx);
            }
        } finally {
            crosshairSyncing = false;
        }
    });
}

// ===== Indicator rendering =====
function renderIndicators(panelIdx) {
    if (!charts[panelIdx]) return;
    const candles = panelCandles[panelIdx];
    if (!candles.length) return;
    const active = panelIndicators[panelIdx];
    const series = panelIndSeries[panelIdx];
    const chart = charts[panelIdx].chart;

    // Remove old indicator series
    Object.keys(series).forEach(k => {
        if (Array.isArray(series[k])) {
            series[k].forEach(s => { try { chart.removeSeries(s); } catch(e) {} });
        } else {
            try { chart.removeSeries(series[k]); } catch(e) {}
        }
    });
    panelIndSeries[panelIdx] = {};

    // MA lines
    ['MA5', 'MA10', 'MA20'].forEach(key => {
        if (!active[key]) return;
        const period = parseInt(key.replace('MA', ''));
        const ind = INDICATORS.find(i => i.key === key);
        const data = calcMA(candles, period);
        if (data.length) {
            const s = chart.addSeries(LightweightCharts.LineSeries, {
                color: ind.color, lineWidth: 1, priceLineVisible: false, lastValueVisible: false,
            });
            s.setData(data);
            panelIndSeries[panelIdx][key] = s;
        }
    });

    // Bollinger Bands
    if (active.BB20) {
        const bb = calcBB(candles, 20, 2);
        if (bb.mid.length) {
            const sMid = chart.addSeries(LightweightCharts.LineSeries, { color: '#a78bfa', lineWidth: 1, priceLineVisible: false, lastValueVisible: false });
            const sUp = chart.addSeries(LightweightCharts.LineSeries, { color: 'rgba(167,139,250,0.4)', lineWidth: 1, lineStyle: 2, priceLineVisible: false, lastValueVisible: false });
            const sLo = chart.addSeries(LightweightCharts.LineSeries, { color: 'rgba(167,139,250,0.4)', lineWidth: 1, lineStyle: 2, priceLineVisible: false, lastValueVisible: false });
            sMid.setData(bb.mid); sUp.setData(bb.upper); sLo.setData(bb.lower);
            panelIndSeries[panelIdx].BB20 = [sMid, sUp, sLo];
        }
    }

    // MACD
    if (active.MACD) {
        const macd = calcMACD(candles, 12, 26, 9);
        if (macd.histogram.length) {
            const sHist = chart.addSeries(LightweightCharts.HistogramSeries, {
                priceScaleId: 'macd', priceFormat: { type: 'price', precision: 2, minMove: 0.01 },
            });
            chart.priceScale('macd').applyOptions({ scaleMargins: { top: 0.7, bottom: 0 } });
            sHist.setData(macd.histogram);
            const sMacd = chart.addSeries(LightweightCharts.LineSeries, {
                color: '#f97316', lineWidth: 1, priceScaleId: 'macd', priceLineVisible: false, lastValueVisible: false,
            });
            sMacd.setData(macd.macd);
            const sSig = chart.addSeries(LightweightCharts.LineSeries, {
                color: '#38bdf8', lineWidth: 1, priceScaleId: 'macd', priceLineVisible: false, lastValueVisible: false,
            });
            sSig.setData(macd.signal);
            panelIndSeries[panelIdx].MACD = [sHist, sMacd, sSig];
        }
    }
}

function initIndicatorButtons() {
    for (let i = 0; i < 3; i++) {
        const group = document.getElementById('ind-group-' + i);
        if (!group) continue;
        group.innerHTML = '';
        INDICATORS.forEach(ind => {
            const btn = document.createElement('button');
            btn.className = 'ind-btn' + (panelIndicators[i][ind.key] ? ' active' : '');
            btn.textContent = ind.label;
            btn.dataset.ind = ind.key;
            btn.onclick = () => {
                panelIndicators[i][ind.key] = !panelIndicators[i][ind.key];
                btn.classList.toggle('active', panelIndicators[i][ind.key]);
                renderIndicators(i);
            };
            group.appendChild(btn);
        });
    }
}

function updateIndButtons(panelIdx) {
    const group = document.getElementById('ind-group-' + panelIdx);
    if (!group) return;
    group.querySelectorAll('.ind-btn').forEach(btn => {
        btn.classList.toggle('active', !!panelIndicators[panelIdx][btn.dataset.ind]);
    });
}

// ===== UI Logic =====
function calcCTS(candles) {
    if (!candles || candles.length < 25) return { score: 50, momentum: 50, trend: 50, volume: 50 };
    const closes = candles.map(c => c.close);
    const n = closes.length;
    function ma(period) { let s=0; for(let i=n-period;i<n;i++) s+=closes[i]; return s/period; }
    const ma5 = ma(5), ma10 = ma(10), last = closes[n-1];
    const momentum = Math.round(50 + 50 * Math.tanh((last - ma5)/ma5*50));
    const trend = Math.round(50 + 50 * Math.tanh((last - ma10)/ma10*35));
    const volume = Math.round(45 + Math.random()*30);
    const score = Math.round(0.4*momentum + 0.4*trend + 0.2*volume);
    return { score, momentum, trend, volume };
}

function updateAIPanel(cts) {
    const el = document.getElementById('ai-score');
    el.textContent = cts.score;
    el.className = 'score ' + (cts.score >= 65 ? 'high' : cts.score >= 40 ? 'mid' : 'low');
    ['momentum', 'trend', 'volume'].forEach(key => {
        const v = cts[key];
        document.getElementById('bar-'+key).style.width = v+'%';
        document.getElementById('bar-'+key).style.background = v>=65?'#ef4444':v>=40?'#eab308':'#22c55e';
        const lbl = document.getElementById('bar-'+key+'-label');
        lbl.textContent = v>=65?'å¼·å‹¢':v>=40?'ä¸­æ€§':'åå¼±';
        lbl.style.color = v>=65?'#ef4444':v>=40?'#eab308':'#22c55e';
    });
}

function getProductName(product) {
    return product.futureId ? `${product.name} (${product.futureId})` : product.name;
}

function setLoading(id, show) {
    const el = document.getElementById('loading-' + id);
    if (el) el.style.display = show ? 'block' : 'none';
}

function updateBadge(panelIdx) {
    const name = currentProduct ? getProductName(currentProduct) : '--';
    const tf = TIMEFRAMES.find(t => t.key === panelTF[panelIdx]);
    document.getElementById('badge-' + panelIdx).textContent = name + ' ' + (tf ? tf.label : '');
    const group = document.getElementById('tf-group-' + panelIdx);
    if (group) group.querySelectorAll('.tf-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tf === panelTF[panelIdx]);
    });
}

function updateKBarCount(panelIdx) {
    const el = document.getElementById('kbar-count-' + panelIdx);
    if (el) el.textContent = 'å…± ' + panelCandles[panelIdx].length + ' æ ¹';
}

async function renderPanel(panelIdx) {
    if (!rawCandles.length && panelTF[panelIdx] !== 'D') return;
    // Destroy old chart
    if (charts[panelIdx]) { charts[panelIdx].chart.remove(); charts[panelIdx] = null; }
    panelIndSeries[panelIdx] = {};
    setLoading(panelIdx, true);

    const tfKey = panelTF[panelIdx];
    const isDaily = tfKey === 'D';
    charts[panelIdx] = makeChart('chart-' + panelIdx, isDaily);
    if (!charts[panelIdx]) return;

    let candles, volumes;

    if (isDaily) {
        // Fetch multi-day data
        const symbol = currentProduct.stockId;
        const result = await fetchDailyData(symbol, DATA_DATE, 20);
        candles = result.candles;
        volumes = result.volumes;
    } else if (tfKey === '1m') {
        candles = rawCandles;
        volumes = rawVolumes;
    } else {
        const tf = TIMEFRAMES.find(t => t.key === tfKey);
        const agg = aggregateBars(rawCandles, rawVolumes, tf.minutes);
        candles = agg.candles;
        volumes = agg.volumes;
    }

    panelCandles[panelIdx] = candles;
    panelVolumes[panelIdx] = volumes;

    charts[panelIdx].candleSeries.setData(candles);
    charts[panelIdx].volumeSeries.setData(volumes);

    // Render active indicators
    renderIndicators(panelIdx);

    // Setup crosshair sync
    setupCrosshairSync(panelIdx);

    charts[panelIdx].chart.timeScale().fitContent();
    setLoading(panelIdx, false);
    updateBadge(panelIdx);
    updateKBarCount(panelIdx);
    showLatestOHLC(panelIdx);
}

function switchTF(panelIdx, tfKey) {
    panelTF[panelIdx] = tfKey;
    renderPanel(panelIdx);
}

function initTFButtons() {
    for (let i = 0; i < 3; i++) {
        const group = document.getElementById('tf-group-' + i);
        if (!group) continue;
        group.innerHTML = '';
        TIMEFRAMES.forEach(tf => {
            const btn = document.createElement('button');
            btn.className = 'tf-btn' + (panelTF[i] === tf.key ? ' active' : '');
            btn.textContent = tf.label;
            btn.dataset.tf = tf.key;
            btn.onclick = () => switchTF(i, tf.key);
            group.appendChild(btn);
        });
    }
}

async function loadProduct(product) {
    currentProduct = product;
    document.getElementById('ai-stock-name').textContent = getProductName(product);

    // Destroy old
    for (let i = 0; i < 3; i++) { if (charts[i]) { charts[i].chart.remove(); charts[i] = null; } panelIndSeries[i] = {}; setLoading(i, true); }

    // Fetch 1m data
    const data = await fetchKLineData(product.stockId, DATA_DATE, '1m');

    if (data && data.length > 0) {
        const parsed = apiToCandles(data, DATA_DATE);
        rawCandles = parsed.candles;
        rawVolumes = parsed.volumes;

        for (let i = 0; i < 3; i++) await renderPanel(i);

        updateAIPanel(calcCTS(rawCandles));
        document.getElementById('data-info').textContent = 'æ•¸æ“šä¾†æº: ' + DATA_DATE + ' çœŸå¯¦è¡Œæƒ… (ç¾è²¨)';
    } else {
        rawCandles = []; rawVolumes = [];
        for (let i = 0; i < 3; i++) setLoading(i, false);
        document.getElementById('data-info').textContent = 'ç„¡è³‡æ–™';
    }
    renderList();
}

function renderList() {
    const el = document.getElementById('watchlist');
    if (!el) return;
    el.innerHTML = '';
    const list = currentTab === 'futures' ? futuresList : twStocks;
    
    list.forEach(item => {
        const div = document.createElement('div');
        const isActive = currentProduct && (item.futureId ? item.futureId === currentProduct.futureId : item.stockId === currentProduct.stockId);
        div.className = 'stock-row' + (isActive ? ' active' : '');
        div.onclick = () => loadProduct(item);
        
        const symbolDisplay = item.futureId ? item.futureId : item.stockId;
        const subDisplay = item.futureId ? item.stockId : '';
        
        div.innerHTML = `
            <div class="stock-info">
                <span class="symbol">${symbolDisplay} <span style="font-weight:normal;color:#6b7280;font-size:11px">${subDisplay}</span></span>
                <span class="name">${item.name}</span>
            </div>
            <div class="price-box">
                <div class="price text-up">--</div>
            </div>`;
        el.appendChild(div);
    });
}

function switchTab(tab) {
    currentTab = tab;
    document.querySelectorAll('.tab').forEach((t, i) => t.className = 'tab' + (['futures', 'tw'][i] === tab ? ' active' : ''));
    renderList();
}

// ===== Init =====
(async function init() {
    if (typeof LightweightCharts === 'undefined') {
        document.body.innerHTML = '<div style="color:red;padding:40px">åœ–è¡¨åº«è¼‰å…¥å¤±æ•—</div>';
        return;
    }
    
    initTFButtons();
    initIndicatorButtons();
    // Load Futures List
    const prods = await fetchProductList();
    if (prods.length > 0) {
        futuresList = prods;
        loadProduct(futuresList[0]);
    } else {
        futuresList = [
            { stockId: '2330', futureId: 'CDFC6', name: 'å°ç©é›»æœŸ03' },
            { stockId: '2317', futureId: 'DHFC6', name: 'é´»æµ·æœŸ03' }
        ];
        loadProduct(futuresList[0]);
    }
})();
</script>
</body>
</html>
